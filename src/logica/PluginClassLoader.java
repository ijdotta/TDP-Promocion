package logica;import java.io.DataInputStream;import java.io.File;import java.io.FileInputStream;/* * In order to impose tight security restrictions on untrusted classes but * not on trusted system classes, we have to be able to distinguish between * those types of classes. This is done by keeping track of how the classes * are loaded into the system. By definition, any class that the interpreter * loads directly from the CLASSPATH is trusted. This means that we can't * load untrusted code in that way--we can't load it with Class.forName(). * Instead, we create a ClassLoader subclass to load the untrusted code. * This one loads classes from a specified directory (which should not * be part of the CLASSPATH). */import java.io.IOException;/** * Class PluginClassLoader *  * @author Ignacio Joaquín Dotta *  */public class PluginClassLoader extends ClassLoader {		protected File directory;	public PluginClassLoader(File dir, ClassLoader classLoader) {		super(classLoader);		directory = dir;	}		@Override	protected Class<?> findClass(String name) throws ClassNotFoundException {		String classname = name.replace('.', File.separatorChar) + ".class";		System.out.println("classname : " + classname);		byte[] classbytes = readFromFile(classname); 		return defineClass(name, classbytes, 0, classbytes.length);	}	private byte[] readFromFile(String classname) {		File f = new File(this.directory, classname);		System.out.println("file : " + f.getPath());		int length = (int) f.length();		byte[] classbytes = new byte[length];				try {						DataInputStream in = new DataInputStream(new FileInputStream(f));			in.readFully(classbytes);			in.close();					} catch (IOException e) {			e.printStackTrace();		}				return classbytes;	}	}