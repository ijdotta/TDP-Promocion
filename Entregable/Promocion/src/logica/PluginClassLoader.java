package logica;import java.io.DataInputStream;import java.io.File;import java.io.FileInputStream;/* * In order to impose tight security restrictions on untrusted classes but * not on trusted system classes, we have to be able to distinguish between * those types of classes. This is done by keeping track of how the classes * are loaded into the system. By definition, any class that the interpreter * loads directly from the CLASSPATH is trusted. This means that we can't * load untrusted code in that way--we can't load it with Class.forName(). * Instead, we create a ClassLoader subclass to load the untrusted code. * This one loads classes from a specified directory (which should not * be part of the CLASSPATH). */import java.io.IOException;import java.util.logging.ConsoleHandler;import java.util.logging.Handler;import java.util.logging.Level;import java.util.logging.Logger;/** * Class PluginClassLoader *  * @author Ignacio Joaquín Dotta *  */public class PluginClassLoader extends ClassLoader {	private static Logger logger;	protected File directory;	/**	 * Construye un ClassLoder personalizado para los PluginOperacion.	 * 	 * @param dir         Directorio de búsqueda de archivos .class de plugins.	 * @param classLoader define el classLoader padre al que se le delega la carga	 *                    de clases.	 */	public PluginClassLoader(File dir, ClassLoader classLoader) {		super(classLoader);		directory = dir;		inicializarLogger();	}	@Override	protected Class<?> findClass(String name) throws ClassNotFoundException {		String classname = name.replace('.', File.separatorChar) + ".class";		logger.fine("Classname: " + classname);		byte[] classbytes = readFromFile(classname);		return defineClass(name, classbytes, 0, classbytes.length);	}	/**	 * Carga el archivo de la clase a bytecode para poder definir la clase a través	 * del método defineClass	 * 	 * @param classname Nombre del archivo .class	 * @return bytecode asociado a la clase.	 */	private byte[] readFromFile(String classname) {		File f = new File(this.directory, classname);		logger.fine("Class file: " + f.getPath());		int length = (int) f.length();		byte[] classbytes = new byte[length];		try {			DataInputStream in = new DataInputStream(new FileInputStream(f));			in.readFully(classbytes);			in.close();		} catch (IOException e) {			e.printStackTrace();			logger.warning("Error al leer " + classname);		}		logger.fine("Lectura de bytecode exitosa. ");		return classbytes;	}	/**	 * Configura el logger de la clase.	 */	private void inicializarLogger() {		if (logger == null) {			logger = Logger.getLogger(this.getClass().getName());			Handler hnd = new ConsoleHandler();			hnd.setLevel(Level.ALL);			logger.addHandler(hnd);			logger.setLevel(Level.ALL);			Logger rootLoger = logger.getParent();			for (Handler h : rootLoger.getHandlers())				h.setLevel(Level.OFF);		}	}}